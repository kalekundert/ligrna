#!/usr/bin/env python3

import autoprop
import unique_variants
from pprint import pprint

@autoprop
class Library:

    def __init__(self, initial_size):
        # The number of members in the library at each step.
        self.sizes = [initial_size]

    def get_current_size(self):
        return self.sizes[-1]

    def pick(self, num_picked):
        self.sizes.append(
                unique_variants.unique_items(
                    self.current_size, num_picked))

    def pick_fraction(self, fraction_picked):
        self.pick(fraction_picked / self.current_size)

    def screen(self, report_path, fraction_picked=None):
        """
        Read the given sort report and update the size of the library 
        accordingly.  Return some parameters about the sort.
        
        Parameters
        ----------
        report_path: str
            The path to the sort report generated by the cytometer.  The report 
            must be in the CSV format (not PDF).

        fraction_picked: float
            The fraction of the library remaining after the screen.  By default 
            this is just the fraction of cells in the gate that was collected, 
            but for later screens I tend to assume that only mistakes are still 
            being sorted, so I set it to 100%.
        """
        report = SortReport(report_path)
        self.pick_fraction(fraction_picked or report.fraction_gated)
        return report


    def debrief_screen(self, overnight_vol, media_vol, condition, report_path,
            gate_desc='{}', event_rate_desc='{}', sort_time_desc='{}',
            fraction_picked=None):
        """
        Update the library size using the information in the given sort report, 
        and return an object that will summarize the given information when 
        displayed in a jupyter notebook.
        """
        report = self.screen(report_path, fraction_picked)
        return ScreenDebrief(
                overnight_vol, media_vol, condition, report,
                gate_desc=gate_desc,
                event_rate_desc=event_rate_desc,
                sort_time_desc=sort_time_desc,
        )


class SortReport:

    def __init__(self, report_path):
        import csv
        with open(report_path) as file:
            reader = csv.reader(file)
            table = [row for row in csv.reader(file)]

        self.elapsed_time_str = table[31][1]
        h,m,s = self.elapsed_time_str.split(':')
        self.elapsed_secs = 3600 * int(h) + 60 * int(m) + int(s)

        self.num_events = int(table[29][1])
        self.event_rate = self.num_events / self.elapsed_secs

        g,n = table[40][2].split(':')
        self.gate = g.strip()
        self.num_sort_events = int(n)
        self.sort_rate = self.num_sort_events / self.elapsed_secs
        self.fraction_gated = self.num_sort_events / self.num_events

    def __repr__(self):
        return f'<SortReport event_rate={self.event_rate:.1f} elapsed_time={self.elapsed_time_str} gate={100 * self.fraction_gated:.1f}% {self.gate}>'


class ScreenDebrief:

    def __init__(self, overnight_vol, media_vol, condition, report,
            gate_desc='{}', event_rate_desc='{}', sort_time_desc='{}'):
        self.overnight_vol = overnight_vol
        self.media_vol = media_vol
        self.condition = condition
        self.report = report
        self.gate_desc = gate_desc
        self.event_rate_desc = event_rate_desc
        self.sort_time_desc = sort_time_desc

    def __reprhtml__(self):
        dl = '<dl>'
        dt = '<dt style="float: left; clear: left; margin-right: 5px">'
        dd = '<dd style="margin-left: 0px">'

        gate = f'{100 * self.report.fraction_gated:.1f}% {self.report.gate}'
        event_rate = f'{self.report.event_rate:.1f} evt/sec'
        sort_time = f'{self.report.elapsed_secs // 3600}h{self.report.elapsed_secs // 60:02}'

        return (f'{dl}'
                f'{dt}Overnight volume</dt>'
                f'{dd}{self.overnight_vol}</dd>'
                f'{dt}Media volume</dt>'
                f'{dd}{self.media_vol}</dd>'
                f'{dt}Condition</dt>'
                f'{dd}{self.condition}</dd>'
                f'{dt}Gate</dt>'
                f'{dd}{self.gate_desc.format(gate)}</dd>'
                f'{dt}Event rate</dt>'
                f'{dd}{self.event_rate_desc.format(event_rate)}</dd>'
                f'{dt}Sort time</dt>'
                f'{dd}{self.sort_time_desc.format(sort_time)}</dd>'
                f'</dl>')

    _repr_html_ = __reprhtml__




